{"categories":[{"title":"Go","uri":"https://hungchang.co/categories/go/"},{"title":"Javascript","uri":"https://hungchang.co/categories/javascript/"},{"title":"Node","uri":"https://hungchang.co/categories/node/"},{"title":"React","uri":"https://hungchang.co/categories/react/"},{"title":"TypeScript","uri":"https://hungchang.co/categories/typescript/"}],"posts":[{"content":"Javascript-原型鏈 Javascript中除了純值之外，剩下的類型其實都是物件，每個物件除了頂層的物件中都有原型，在ECMAScript標準裡面是寫成someObj.[[Prototype]]。\n在瀏覽器中我們常會用.__proto__取得當前物件的原型物件，要注意的是.__proto__是瀏覽器實做訪問原型的方便寫法，正式的讀寫應該使用 Object.getPrototypeOf(someObj) 以及 Object.setPrototypeOf() 這兩個訪問器。但是為了理解，這裡講都會使用.__proto__來做筆記。\n訪問原型鏈 當我們對於一個物件查找屬性找不到時，JS會往原型物件找。\nvar person = { name: \u0026quot;ZZ\u0026quot;, age: 24 } person.__proto__.height = 1.65 console.log(person.height) // 1.65  原本應該沒有height屬性，但在person物件的原型物件上加上屬性後便會從person往上找person.__proto__找有沒有height屬性，將結果輸出。\n然而\n參考連結 MDN\n","id":0,"section":"posts","summary":"Javascript-原型鏈 Javascript中除了純值之外，剩下的類型其實都是物件，每個物件除了頂層的物件中都有原型，在ECMAScri","tags":["Javascript"],"title":"Javascript-原型鏈","uri":"https://hungchang.co/2022/05/javascript-prototype-chain/","year":"2022"},{"content":"React 下載  下載node 下載react  npx create-react-app my-app cd my-app npm start  閱讀官方docs後的心得 以資料結構想畫面，盡量讓資料結構跟畫面能夠結合在一起。 操控資料要使用useState import { useState } from 'react'; const [inputText, setInputText] = useState(\u0026quot;init word\u0026quot;)  useState會回傳一個陣列，陣列的第一個是變數，第二個則是操縱資料變化的函數，其命名方法會是一個名詞，另一個是 “set名詞” 。一開始useState裡要傳入初始化的數值當作參數。\n inputText 值只會被初始化一次。\n React要做到雙向綁定(資料綁畫面，畫面改動寫回資料)需要手動調用useState的第二個函數。 操作資料一定要使用setInputText，不可以直接賦值變數。\n如果資料是由父傳子，想要改變狀態可以將setInputText()當成props傳下去。 並且傳下去的名稱會使用 on + 名詞 + 操作動作，如同onInputTextChange\n細部探討 - Component 每一個物件都是一個function，並且回傳jsx。使用export可以導出元件，在其他文件導入來複用。\n一個文件export default 只能有一個，但可以有多個export。導入方式根據是不是default有所不同。\n// a.js export default function Profile(){...} export function Other1() {...} export function Other2() {...} // b.js import Profile from './a.js' import { Other1, Other2 } from './a.js'   要注意react的function名稱一定是要大寫開頭命名才會有作用。主要是因為要區分是html的tag還是是react的component.\n 細部探討 - export 和 import 在react的專案中，src/App.js是app的根。除非是用Next.js，它的每個頁面的跟才會不一樣。\n在import的時候可以不加副檔名.js，這是因為es module的特性。\n細部探討 - JSX 在撰寫JSX的時候有些地方與html不一樣。下面條列規則\n 必須只有一個根包住整個結構，可以用，也可以使用\u0026lt;\u0026gt;\u0026lt;/\u0026gt;  \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;JSX\u0026lt;/h1\u0026gt; \u0026lt;img\u0026gt; \u0026lt;/div\u0026gt;  \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;JSX\u0026lt;/h1\u0026gt; \u0026lt;img\u0026gt; \u0026lt;/\u0026gt;  這個\u0026lt;\u0026gt;\u0026lt;/\u0026gt;特別的tag叫做React fragment。不能夠有兩個以上的root是因為jsx最終都會被轉成js物件，一個function裡不能同時兩個物件在沒有展開的情況下。\n","id":1,"section":"posts","summary":"React 下載 下載node 下載react npx create-react-app my-app cd my-app npm start 閱讀官方docs後的心得 以資料結構想畫面，盡量讓資料結構跟畫面能夠結合在一起。 操控資料要使用u","tags":["React"],"title":"React初體驗","uri":"https://hungchang.co/2022/05/react/","year":"2022"},{"content":"創建一個Https伺服器 首先我們要先產生一個憑證\nopenssl req -newkey rsa:2048 -nodes -keyout server.key -x509 -days 365 -out server.crt  接著打上以下的程式碼\n// https.go package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; ) func main() { srv := \u0026amp;http.Server{Addr: \u0026quot;:9001\u0026quot;, Handler: http.HandlerFunc(handle)} log.Printf(\u0026quot;Serving on http://0.0.0.0:9001\u0026quot;) log.Fatal(srv.ListenAndServeTLS(\u0026quot;server.crt\u0026quot;, \u0026quot;server.key\u0026quot;)) } func handle(w http.ResponseWriter, r *http.Request) { log.Printf(\u0026quot;Got connection: %s\u0026quot;, r.Proto) w.Write([]byte(\u0026quot;Hello, this is a HTTP 2 message\u0026quot;)); }  在瀏覽器打上https://0.0.0.0:9001便可以看到\u0026quot;Hello, this is a HTTP 2 message\u0026quot;\n","id":2,"section":"posts","summary":"創建一個Https伺服器 首先我們要先產生一個憑證 openssl req -newkey rsa:2048 -nodes -keyout server.key -x509 -days 365 -out server.crt 接著打上以下的程式碼 // https.go package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; ) func main() { srv := \u0026amp;http.Server{Addr: \u0026quot;:9001\u0026quot;, Handler: http.HandlerFunc(handle)} log.Printf(\u0026quot;Serving on http://0.0.0.0:9001\u0026quot;) log.Fatal(srv.ListenAndServeTLS(\u0026quot;server.crt\u0026quot;, \u0026quot;server.key\u0026quot;)) }","tags":["Go"],"title":"Go-net/HTTP創建伺服器","uri":"https://hungchang.co/2022/05/go-nethttp/","year":"2022"},{"content":"初學TypeScript 原本想用Go學習後端，但是大家建議先學好TS並且加上Node.js練習，等到熟悉了再學習Go，加上工作剛好\n未來有需求要使用TypeScript，因此我來學習TypeScript了。網路上找到覺得最好的教學就是由Maxwell\n寫的文章，寫得相當詳細，我還買了他的書來詳讀。本篇文章都是拜讀書籍的內容，強烈建議大家購買。\n附上連結讓 TypeScript 成為你全端開發的 ACE！系列，作者：Maxwell\nTS的原始型別 Primitive Types js的原始型別有number, string, boolean, undefined, null, void\nlet num = 123; let message = 'Hello world'; let truthy = true; let meansEmpty = undefined; // any let meansNothing = null; // any  這裡直接賦值undefined和null不是好事情因此我們必須型別註記一下。\nlet meansEmpty: undefined = undefined; let meansNothing: null = null;  遲滯性指派Delayed Initialization 當我們一開始宣告一個變數，卻沒有賦予值的時候，TypeScript也會把變數當成any。\nlet num; // any console.log(num); // undefined num = 123;  上面的例子並不會報錯，因為num被判別成any的緣故，這顯然很糟糕。因此我們必須一開始型別註記避免發生 沒有預期的錯誤。\nlet num:number; console.log(num); // 報錯  let num:number | undefined; console.log(num) // 不會報錯  JSON物件的型別 物件的型別註記長得像下面一樣\nlet info : { name: string; age: number; interest: string[]; } = { name: 'wyatt', age: 24, interest: ['drawing', 'programming'] }  只是上面看起來實在是太複雜了，因此我們把物件結構抽出來。這裡可以使用\u0026quot;型別化名\u0026quot;簡潔程式，型別化名 可以抽象化。\ntype PersonalInfo = { name: string; age: number; interest: string[]; } let info: PersonalInfo = { name: 'Wyatt', age: 24, interest: ['programming', 'play game'] }  物件的完整性 物件不可以隨便新增及刪除，並且更改值必須符合物件結構的型別。\ninfo.email = 'test@gmail.com' // 報錯 delete info.name; // 也會報錯了 info.name = 'Wayne' // 這種複寫因為型別一樣可以  全部複寫是可以的，但還是一樣要符合型別\ninfo = { name: \u0026quot;Wayne\u0026quot;, age: info.age, interest: info.interest, } // ES7(Rest-Spread Operator)寫法 info = {...info, name: 'Wayne'} info = {...info, name: 123} // 報錯，string不可以賦值number  唯獨屬性 我們有時候會希望物件不可以被覆寫，可以使用readonly。\ntype PersonalInfo = { name: string, readonly age: number; interest: string[]; } let info: PersonalInfo = { name: \u0026quot;wyatt\u0026quot;, age: 24, interest: [\u0026quot;programming\u0026quot;] } info.age = 25; // 報錯，因為readonly  有時候我們是引用別人寫的程式，為了避免型別化名的自由度降低，但避免物件太過自由的方法可以用下面的 方法。\ntype PersonalInfo = { name: string; age: number; interest: string[]; } let info: Readonly\u0026lt;PersonalInfo\u0026gt; = { name: \u0026quot;wyatt\u0026quot;, age: 24, interest: [\u0026quot;programming\u0026quot;] } info.age = 25; // 也會報錯  函式的型別 大多函數的參數都會被判別成any，因此涵式的輸入都必須要進行註記的動作\n 宣告變數，將函數當成物件值  let addition1: (a: number, b: number) =\u0026gt; number = function(a, b) { return a + b; }  宣告變數，將函數當成物件值，在韓式宣告輸入輸出時，一併註記。  let addition2 = function (a: number, b: number): number { return a + b; }  函數宣告，輸入、輸出時註記  function addition3(a: number, b: number): number { return a + b }  函數物件值屬於表達式，使用斷言註記法  let addition4 = function(a, b) { return a + b } as (a: number, b: number) =\u0026gt; number;  選用參數 - 只能在參數的尾端 // ok function sumFrom3Nums(input1: number, input2?: number, input3?: number) { return input1 + (input2 ? input2 : 0) + (input3 ? input3 : 0); } // 不ok function sumFrom3Nums(input1: number, input2?: number, input3: number) { return input1 + (input2 ? input2 : 0) + (input3 ? input3 : 0); }  預設參數 使用空值連結操作符(Nullish Coalescing Operator)\nfunction increment(input1: number, input2?:number) { const value = input2 ?? 1; return input1 + value }  通常我們會寫成下面這樣\nfunction increment(input1: number, input2: number = 1) { return input1 + input2 }  陣列型別 二維陣列\nconst points = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] // 型別判別是int[][]  如果想在陣列裡放速不同型態的可以寫成下面的樣子(要注意括號要加)\nconst arr1: (number | string)[] = [1, 2, 3]; const arr2: number | string[] = [1, 2, 3]; // 這個意思是數字或是字串型別陣列，會報錯  明文類別 使用let宣告變數並指派原始型別的值，被推論的不是明文型別，而是明文代表的型別。\n使用const則選告變數是指派原始型別值， 並且被推論的是明文型別。\n以下是純值的型別註記\nlet jsonObj: { foo: 123, bar: \u0026quot;Hello\u0026quot; } = { foo: 123, bar: \u0026quot;Hello\u0026quot; }; jsonObj.foo = 123; jsonObj.foo = 456; 不行，會報錯  ","id":3,"section":"posts","summary":"初學TypeScript 原本想用Go學習後端，但是大家建議先學好TS並且加上Node.js練習，等到熟悉了再學習Go，加上工作剛好 未來有需求","tags":["TypeScript"],"title":"TypeScript","uri":"https://hungchang.co/2022/05/typescriptbasic/","year":"2022"},{"content":"初學Node HTTP,HTTPS 超文本傳輸協定，瀏覽器與伺服器交換資料的協定。\n Http: Hyper Text Transfer Protocol Https: Hyper Text Transfer Protocol Secure。 HTTP + Data Encryption (during Transmission)。  Node創建一個簡單的伺服器 app.js\nconst http = require('http') function requestHandler(req, res, next) =\u0026gt; { console.log(req.url, req.method, req.headers); // process.exit() // 這樣寫會結束程式 next(); // 這裡的next是一個函數，代表讓城市繼續進行下去，前往下一個中間件。 } const server = http.createServer(requestHandler) // 這裡NodeJS會一直監聽有沒有request server.listen(3000); // server監聽port3000  當我們node.js app.js後，會開始解析程式，編譯之後註冊變數和函數，接著js引擎提供event loop，會持續\n等待event listener註冊，直到行程結束(這裡是指app.js程式結束才會結束)。\n分離路徑 通常網頁會有不同的請求，通通把所有request判斷都寫在app.js會相當複雜不易閱讀，因此我們通常會根據不同功能拆分路徑。\n在根目錄下底下創建 routes.js，把我們剛才的requestHandler分離出去。\nconst fs = require(\u0026quot;fs\u0026quot;); // node的資料夾裡的file system const requestHandler = (req, res) =\u0026gt; { // * sending response const url = req.url; // 我們取得了使用者輸入的url const method = req.method; // 使用者使用的請求方式(GET? POST?...) if (url === \u0026quot;/\u0026quot;) { res.write(\u0026quot;\u0026lt;html\u0026gt;\u0026quot;); res.write(\u0026quot;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Enter Message\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026quot;); res.write( '\u0026lt;body\u0026gt;\u0026lt;form action=\u0026quot;/message\u0026quot; method=\u0026quot;POST\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;message\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Send\u0026lt;/button\u0026gt;\u0026lt;/form\u0026gt;\u0026lt;/body\u0026gt;' ); res.write(\u0026quot;\u0026lt;/html\u0026gt;\u0026quot;); return res.end(); //結束傳送資料給客戶端，不繼續執行下去，後面不會繼續執行下去，因此我們在這裡return } if (url === \u0026quot;/message\u0026quot; \u0026amp;\u0026amp; method === \u0026quot;POST\u0026quot;) { const body = []; req.on(\u0026quot;data\u0026quot;, (chunk) =\u0026gt; { console.log(chunk); body.push(chunk); }); return req.on(\u0026quot;end\u0026quot;, () =\u0026gt; { const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split(\u0026quot;=\u0026quot;)[1]; console.log(parsedBody); fs.writeFile(\u0026quot;message.txt\u0026quot;, message, (err) =\u0026gt; { res.statusCode = 302; res.setHeader(\u0026quot;Location\u0026quot;, \u0026quot;/\u0026quot;); return res.end(); }); }); } res.setHeader(\u0026quot;Content-Type\u0026quot;, \u0026quot;text/html\u0026quot;); res.write(\u0026quot;\u0026lt;html\u0026gt;\u0026quot;); res.write(\u0026quot;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;My First Page\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026quot;); res.write(\u0026quot;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;Hello from my Node.js Server!\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026quot;); res.write(\u0026quot;\u0026lt;/html\u0026gt;\u0026quot;); res.end(); //結束傳送資料給客戶端 }; module.exports = requestHandler exports.handler = requestHandler; exports.someText = 'Some hard coded text'  上面的程式碼分段解釋\nconst url = req.url; // 我們取得了使用者輸入的url const method = req.method; // 使用者使用的請求方式(GET? POST?...) if (url === \u0026quot;/\u0026quot;) { res.write(\u0026quot;\u0026lt;html\u0026gt;\u0026quot;); res.write(\u0026quot;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Enter Message\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026quot;); res.write( '\u0026lt;body\u0026gt;\u0026lt;form action=\u0026quot;/message\u0026quot; method=\u0026quot;POST\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;message\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Send\u0026lt;/button\u0026gt;\u0026lt;/form\u0026gt;\u0026lt;/body\u0026gt;' ); res.write(\u0026quot;\u0026lt;/html\u0026gt;\u0026quot;); return res.end(); //結束傳送資料給客戶端，不繼續執行下去，後面不會繼續執行下去，因此我們在這裡return }  這裡當我們輸入http://localhost:3000/，會得到上面回傳的表單，裡面可以輸入資料並且POST到路徑/message。\nif (url === \u0026quot;/message\u0026quot; \u0026amp;\u0026amp; method === \u0026quot;POST\u0026quot;) { const body = []; req.on(\u0026quot;data\u0026quot;, (chunk) =\u0026gt; { console.log(chunk); body.push(chunk); }); return req.on(\u0026quot;end\u0026quot;, () =\u0026gt; { const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split(\u0026quot;=\u0026quot;)[1]; console.log(parsedBody); fs.writeFile(\u0026quot;message.txt\u0026quot;, message, (err) =\u0026gt; { res.statusCode = 302; res.setHeader(\u0026quot;Location\u0026quot;, \u0026quot;/\u0026quot;); return res.end(); }); }); }  當我們POST到/message後便會符合路徑url === \u0026lsquo;message\u0026rsquo;和 method === \u0026lsquo;POST\u0026rsquo;，\n這裡我們寫上req.on(\u0026lsquo;data\u0026rsquo;)代表監聽傳來的資料，這裡有一個要補充的知識就是Buffer， 在接受傳輸的資料時候，伺服器會將一整個資料流(stream)分成好幾塊(chunk)接受，完成後再拼接一起轉換成可讀的資料。  這裡這張圖並不是Node.js運行的樣子，只是為了說明資料會像這樣分成好幾塊。\n 等到所有的資料都接收到，便會呼叫req.on(\u0026ldquo;end\u0026rdquo;,()=\u0026gt; {/執行這裡的程式/})\n我們便可以調用Buffer.concat()的方法把資料串起來，並且轉換成字串。\n最後我們在使用fs.writeFile來寫入檔案，並且給http狀態碼302(轉址)，將頁面轉回原來的表單頁面。\n結論 我們可以發現因為js引擎是single thread也就是說一次只做一件事，如果今天有一個檔案很大，某個使用者請求了，\n那樣程式就會在原地等待讀取檔案結束才繼續進行下去。那樣另外一個使用者也發起同樣的請求，他便會需要等到前面的\n使用者請求完成才可以繼續處理該名使用者的請求，這相當不合理。因此我們的function就必須要是非同步的，\n當我們有請求的時候，將處理交給額外的worker pool，等到處理完的時候，便通知event loop裡面註冊的listener，\n去執行裡面的回調函數來處理接下來的步驟。\n","id":4,"section":"posts","summary":"初學Node HTTP,HTTPS 超文本傳輸協定，瀏覽器與伺服器交換資料的協定。 Http: Hyper Text Transfer Protocol Https: Hyper Text Transfer Protocol Secure。 HTTP + Data Encryption (during Transmission)。 Node","tags":["Node"],"title":"Node學習-Server、Stream/Buffer","uri":"https://hungchang.co/2022/05/nodestarter/","year":"2022"},{"content":"Node模組-path Node讀取資料夾及文件的路徑經常使用的。\nresolve使用: path.resolve const path = require('path'); const basePath = '\\\\User\\\\Wyatt'; const filename = 'test.txt'; // const filePath = basePath + '/' + filename; //使用拼接會有路徑問題 /* 註釋 每個系統使用的路徑分隔符號不一樣 Linux / Mac os / Window \\, \\\\, / IEEE提出可疑值操作系統接口(Portable Operating System Interface，縮寫POSIX) Linux和Mac OS都實現了POSIX接口 Windows電腦的話是部分實現POSIX接口 */ const filePath = path.resolve(basePath, filename) // 這裡會幫我們處理basePath裡面路徑的分割符號 console.log(filePath) // D:\\User\\Wyatt\\test.txt  獲得路徑的資訊: path.xxx const path = require('path'); // 1.獲取路徑訊息 const filepath = '/User/Wyatt/test.txt' console.log(path.dirname(filepath)); // /User/Wyatt console.log(path.basename(filepath)); // test.txt console.log(path.extname(filepath)); // .txt  路徑的拼接: join和resolve的不同 // 2. join拼接 const basepath = '../User/Wyatt'; const filename = 'test.txt'; const filepath = path.join(basepath, filename); console.log(filepath) // ..\\User\\Wyatt\\test.txt // 3. resolve拼接 // resolve會判斷拼接的路徑中，是否有以/或./或../開頭的路徑 const filepath2 = path.resolve(basepath, filename); console.log(filepath2) // D:\\Node\\05_常見的模組\\User\\Wyatt\\test.txt  ","id":5,"section":"posts","summary":"Node模組-path Node讀取資料夾及文件的路徑經常使用的。 resolve使用: path.resolve const path = require('path'); const basePath = '\\\\User\\\\Wyatt'; const filename = 'test.txt'; // const filePath = basePath + '/' + filename; //使用拼接","tags":["Node"],"title":"Node模組-path","uri":"https://hungchang.co/2022/05/node-path/","year":"2022"},{"content":" 全文皆來自自學Youtube的教學影片Learn Go Programming - Golang Tutorial for Beginners，講得相當好，大家可以點進去學習。\n Array array是一個固定長度的資料且並非指標的值，在Go中array只能裝同樣類型的資料。\n Array各種聲明方法，要注意只能裝同個類型。  package main import ( \u0026quot;fmt\u0026quot; ) func main() { // 三種聲明array的方式 grades := [3]{12, 55, 77} points := [...]{23, 55, 77} // 會自動偵測元素有多少個來決定長度 var students [3]string // 我們可以更換array的值 students[0] = \u0026quot;Wyatt\u0026quot; students[1] = \u0026quot;Wayne\u0026quot; students[2] = \u0026quot;Peter\u0026quot; fmt.Printf(\u0026quot;Grades: %v\\n\u0026quot;, grades) fmt.Printf(\u0026quot;Students: %v\u0026quot;, students) // 我們可以用len()來取得 fmt.Printf(\u0026quot;Numbers of Student:\u0026quot;, len(students)) }  可以創建一個多維的陣列  package main import ( \u0026quot;fmt\u0026quot; ) func main() { var matrix [3][3]int = [3][3]{[3]int{1, 0, 0}, [3]int{0, 1, 0}, [3]int{0, 0, 1}} // 上面很複雜，可以用下面的方法比較清楚 var identityMatrix [3][3]int identityMatrix[0] = [3]int{1, 0, 0} identityMatrix[1] = [3]int{0, 1, 0} identityMatrix[2] = [3]int{0, 0, 1} fmt.Println(identityMatrix) // [[1 0 0] [0 1 0] [0 0 1]] }  以下例子可以證明陣列Array並非指標  a := [...]int{1, 2, 3} b := a b[1] = 5 c := \u0026amp;a // 表示我要指向a的記憶體值 fmt.Println(a) [1, 2, 3] fmt.Println(b) [1, 5, 3] fmt.Println(c) \u0026amp;[1, 2, 3]  由上述例子可以知道b是直接複製a的值到新的記憶體空間，並非複製a指向記憶體的指針。\n","id":6,"section":"posts","summary":"全文皆來自自學Youtube的教學影片Learn Go Programming - Golang Tutorial for Beginners，講得相當好，大家可以點進去學習。 Array array是一個固定長度的","tags":["Go"],"title":"array","uri":"https://hungchang.co/2022/05/array/","year":"2022"},{"content":"struct struct類型 struct就很像是類的概念\npackage main import \u0026quot;fmt\u0026quot; func main() { type game struct { name string stars int category []string } fallguys := game{name: \u0026quot;fallguys\u0026quot;} // 第一種賦值方法 fallguys = game{ name: \u0026quot;糖豆人\u0026quot;, stars: 5.0, category: []string{\u0026quot;funny\u0026quot;}, } // 第二種賦值方法 fallguys = game{\u0026quot;糖豆人\u0026quot;, 5.0, []string{\u0026quot;funny\u0026quot;}} fmt.Println(fallguys) //{糖豆人 5 [funny]} fmt.Println(fallguys.stars) // 5 fmt.Println(fallguys.category) // [funny] fallguys.stars ++ fmt.Println(fallguys.stars) // 6 fallguys.category = append(fallguys.category, \u0026quot;children\u0026quot;) // [funny children] fmt.Println(fallguys.category) type platform struct { name string game game } steam := platform{ name: \u0026quot;steam\u0026quot;, game: fallguys, } fmt.Println(steam) // {steam {糖豆人 6 [funny children]}} fmt.Println(steam.game.stars) // 6 steam.game.stars = 4 fmt.Println(steam.game.stars) // 4 fmt.Println(fallguys.stars) // 6 不會改變，因為steam.game.stars這裡給的是copy的值 type addressSteam struct { name string game *game // 這裡是一個傳入一個參考的值，等等創建struct就會直接傳入參考struct的位置，而非在複製一分資料。 } addressed := addressSteam{\u0026quot;Addressed Steam\u0026quot;, \u0026amp;fallguys} // 這裡給的就是指向fallguys的位置 fmt.Println(addressed) fmt.Println(*addressed.game) addressed.game.stars = 4 fmt.Println(addressed.game.stars) //4 這裡的game指向 fallguys fmt.Println(fallguys.stars) // 4 LOL := new(game) fmt.Println(LOL) // \u0026amp;{ 0 []} fmt.Println(*LOL) // { 0 []} (*LOL).name = \u0026quot;LOL\u0026quot; // 實際上看起來是這樣，但是golang幫忙解決了 LOL.category = []string{\u0026quot;dota\u0026quot;} LOL.stars= 4 intel := cpu{name: \u0026quot;intel\u0026quot;, speed: 100} intel.getPrice() intel.getSpeed() } type cpu struct { name string speed float64 } func (cpu) getPrice() { fmt.Println(\u0026quot;get total price\u0026quot;) } // 像是往cpu這個類別加了一個方法 func (c cpu) getSpeed() { fmt.Println(c.speed) } // 第一個參數是receiver的概念，在Go中稱之為method  ","id":7,"section":"posts","summary":"struct struct類型 struct就很像是類的概念 package main import \u0026quot;fmt\u0026quot; func main() { type game struct { name string stars int category []string } fallguys := game{name: \u0026quot;fallguys\u0026quot;} // 第一種賦值方法 fallguys = game{ name: \u0026quot;糖豆人\u0026quo","tags":["Go"],"title":"struct","uri":"https://hungchang.co/2022/05/struct/","year":"2022"}],"tags":[{"title":"Go","uri":"https://hungchang.co/tags/go/"},{"title":"Javascript","uri":"https://hungchang.co/tags/javascript/"},{"title":"Node","uri":"https://hungchang.co/tags/node/"},{"title":"React","uri":"https://hungchang.co/tags/react/"},{"title":"TypeScript","uri":"https://hungchang.co/tags/typescript/"}]}