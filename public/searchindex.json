{"categories":[{"title":"Daily","uri":"https://hungchang.co/categories/daily/"},{"title":"Go","uri":"https://hungchang.co/categories/go/"},{"title":"Javascript","uri":"https://hungchang.co/categories/javascript/"},{"title":"Node","uri":"https://hungchang.co/categories/node/"},{"title":"React","uri":"https://hungchang.co/categories/react/"},{"title":"TypeScript","uri":"https://hungchang.co/categories/typescript/"}],"posts":[{"content":"I/O (2022/07/04 - 2022/07/10) 上禮拜還是沒有每天都寫紀錄，感覺進度差了一些，要持續的output很重要。\n2022/07/04 每天都在處理圖片沒寫到程式感到疲憊。今天有遇到一個問題，很大很大的圖片在openlayers上顯示不出來。明明在測試的時候都可以，上了正式機卻不行，後來發現是正式機檢查的時候我用edge，然後我測了一下發現只有firefox可以，chrome也不行，看到討論串有說是瀏覽器限制，大概5000*5000以上就不行了，突然覺得firefox很猛，不過這麽大的圖片loading確實很重，希望廠商不要再覺得那麼大的圖片可以放上去了，下載再去下載原圖。\n https://github.com/openlayers/openlayers/issues/10252\n Javascript 今天心血來潮，看回了之前只看了一小段的Javascript奇怪的部分，發現真的很有趣幫忙很多，以前學都還不太清楚，過一陣子後回來看都知道他想表達什麼，很精彩。\n今天簡單講解一下學到的內容\nSyntax Parser、Execution contexts、lexical environments。  Syntax Parser(語法解析器)  編譯器或直譯器解析人寫出來的程式有沒有符合規範，才能轉換成機器懂的語言。   Execution contexts(執行環境|執行脈絡|執行上下文)  一個包裹(包住程式執行的空間)，幫助管理正在執行的程式。 Excution contexts除了自己寫的code和正在執行的code，還包括了很多其他的東西幫助程式執行。   Lexical environments(詞彙環境)  片段程式被寫在哪裡？以及周圍寫了哪些程式，因為編譯器會根據你寫的位置來判斷怎麼轉換成機器讀的語言。    Object 是由一個key/value所組成，在每一個執行上下文中，key是唯一的，不會重複的。\nExcution context包含什麼？  Creation Phase 執行上下文的創建階段會包含以下幾個部分。   global object -\u0026gt; 將會變成全域變數中的其中一個屬性，在執行全域函數或讀取全域變數時才會參照。 this outer environment -\u0026gt; 如果是function execution context會有外部的execution context。 your code -\u0026gt; 自己寫的程式。   Excution Phase  Hoist Javascript會有提升的概念，變數或是函數的提升。 提升並非是把程式移到最前面執行，而是Javascript的Syntax parser讀過程式後交給編譯器處理，會將我們的變數通通存進記憶體當中，並且賦予undefined的值，因此我們發現當我們試圖讀取寫在後面的全域函式或是變數的時候不會報錯。\nconsole.log(myVariable); // undfined Hello(); //Hello! var myVariable = 'a'; function Hello() { console.log('Hello!'); }  undefined undefined在JavaScript中是一個primitive(純值)，所有變數在hoist之後，我們沒有賦予值，Javascript引擎會給我們的值賦予undefined，這是一個\u0026quot;值\u0026quot; 當我們直接讀取一個沒有被創建在記憶的值時會顯示not defined，那跟undefined完全不同。\nSingle Thread \u0026amp; Synchronous  Single Thread   one command at a time.\n 一次執行一個指令。但以瀏覽器來說並不是，這裡指的是javascript引擎本身。\n Synchronous   one at time。依序一行一行讀下來。\n 程式是同步的，意味著每一步驟都必須完成才會繼續進行下去，當讀取到某個函數時，必須等到函式自己的execution context的code執行完，才會繼續往下讀取。\nFunction Invocation And The execution stack  Invocation   running a function. In JS,by using parenthesis()\n Execution stack 全域會有一個execution context，每個函數也都會有自己的excution context，當遇到函數的時候，會形成一個excution context，依照先進後出的規則(這個資料型別我們稱作stack)，意味著要逐行讀，發現函式就放到堆中執行，如果該函式沒有另外函式待自己的程式跑完，將此函式丟出堆中，並且繼續執行呼叫該函式的函式。\nfunction a() { b(); console.log('after b') } function b() { console.log('b excution code run end.') } a(); console.log('c') // 最後輸出是 // b excution code run end. // after b // 'c'  Function, Context, and Variable Environments  Variable Environments   Where the variable live.And how they related to each other in memory\n 除了全域有global的scoped之外，剩下有scoped的就是function，相當於excution context，變數的使用只能在自己所屬的excution context。除了全域變數大家都能讀取使用。\nscoped chain(範圍鏈) 當我們去執行一個函數或者是去讀取一個變數的時候，如果在自己的execution context裡面找不到的話，就會像自己的outer environment去尋找。 而參照的外部環境會是依據我們上述先前提到Lexical environments(詞彙環境)來不斷往外查找，對於javascript來說，詞彙環境也是很重要的，例如我們來看以下的例子。\nAsynchronous非同步回呼 Types And Javascript 範圍、ES6和let Dynamic Typing 函式就是個物件  JS是First-Class Function  JS中函數在可以被視為其他的變數的時候就是一級函式。 因為函式可以指派給其他變數。 函式可以當作參數來傳遞。 函式也可以被回傳。   函數都是物件 函數包含了name(選擇),code(invokable)。 expression(表達式)和stament(敘述式)最大的差異是表達式會回傳值，而敘述式不會。  HTML \u0026lt;!-- html5開頭 --\u0026gt; \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;這是標題\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt; 標題 \u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt; 段落段落 \u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;!-- IE不寫會亂碼 --\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;!-- IE瀏覽器更新到最新 --\u0026gt; \u0026lt;meta http-equiv=\u0026quot;X-UA-Compatible\u0026quot; content=\u0026quot;IE=edge\u0026quot;\u0026gt; \u0026lt;meta name=\u0026quot;viewport\u0026quot; content=\u0026quot;width=device-width, initial-scale=1.0\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  React React.Fragment \u0026lt;React.Fragment\u0026gt; \u0026lt;/React.Fragment\u0026gt;  \u0026lt;\u0026gt; \u0026lt;/\u0026gt;  Portal 渲染html在正確的位置，讓html sementic。\n\u0026lt;div id=\u0026quot;backdrop-root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;modal-root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div id=\u0026quot;root\u0026quot;\u0026gt;\u0026lt;/div\u0026gt;  const BackDrop = (props) =\u0026gt; { return \u0026lt;div className={classes.backdrop} onClick={props.onConfirm}/\u0026gt; } const ModelOverlay = (props) =\u0026gt; { return ... } const Modal = (props) =\u0026gt; { return ( \u0026lt;\u0026gt; {ReactDom.createPortal(\u0026lt;BackDrop onClick={props.onConfirm}/\u0026gt;, document.getElementById('backdrop-root'))} \u0026lt;/\u0026gt; )Ï }  useReducer const [state, dispatchFn]\nNode.js Cookie 瀏覽器用來存資料的地方(可以儲存較小的資料)，後端可以在身份驗證通過時，傳送cookie。\n下禮拜再補上這禮拜沒寫完的部分。\n","id":0,"section":"posts","summary":"I/O (2022/07/04 - 2022/07/10) 上禮拜還是沒有每天都寫紀錄，感覺進度差了一些，要持續的output很重要。 2022/07/04 每天都在處理圖片沒寫到程式感到疲憊。今天有遇到一個問題，","tags":["JavaScript","React","Node.js"],"title":"I/O (2022/07/04 - 2022/07/10)","uri":"https://hungchang.co/2022/07/inputoutput2022-07-04/","year":"2022"},{"content":"I/O (2022/06/27 - 2022/07/01) 每天記錄每天學到什麼，主要是因為這樣子才能及時的輸出，發現要寫長文對自己來說太困難了。而且覺得效率也是一個問題，想要先累積出一些作品，實作比較重要，這樣發發每天的心得比較不會給自己有壓力。\n2022/06/27 Typescript enum enum 列舉，可以把變數範圍在某些範圍下進行存取，\nenum directions {EAST, WEST, SOUTH, NORTH}; console.log(directions.EAST); enum permission {ADMIN = 2, READ_ONLY, WRITE_ONLY} console.log(permission.ADMIN); // 2 console.log(permission.READ_ONLY); // 3 會自動遞增加1 export {}  編譯出來的js程式碼如下\nvar directions; (function (directions) { directions[directions[\u0026quot;EAST\u0026quot;] = 0] = \u0026quot;EAST\u0026quot;; directions[directions[\u0026quot;WEST\u0026quot;] = 1] = \u0026quot;WEST\u0026quot;; directions[directions[\u0026quot;SOUTH\u0026quot;] = 2] = \u0026quot;SOUTH\u0026quot;; directions[directions[\u0026quot;NORTH\u0026quot;] = 3] = \u0026quot;NORTH\u0026quot;; })(directions || (directions = {})); ;  這裡有所謂的反射性，directions[\u0026ldquo;EAST\u0026rdquo;] = 0，這行賦值回傳的也會是0，相當於directions[0] = \u0026ldquo;EAST\u0026rdquo;\nTuple 這個字念tu(ㄩ)ple的音，之前一直唸成a發音。tuple就像陣列，只是與陣列不同的是，他已經規定好長度以及每個索引值裡面的類別了。\nlet array:(number|string)[] // 這是陣列 let array: Array\u0026lt;string | number\u0026gt; // 這跟上面一樣是陣列 let role:[number, string]; // 這是元組 role = [0, \u0026quot;admin\u0026quot;];  我們可能定義了第一個當成某個角色的id，並且指定第二個索引值是角色名稱的字串。我們不能夠隨意的換成不符合的類型。\nlet role:[number, string]; role = [0, true]; // 不行  但要注意的事情是當tuple使用push時，他會檢測不出來不符合型別註記的情況出現。\nlet role:[number, string]; role = [0, true]; // 不行 role.push(\u0026quot;a\u0026quot;) // 不會報錯要小心   TypeScript 資料型別 - 元組(Tuple) \u0026amp; 列舉(Enum)-Kira 這篇文章講得很清楚。\n React 今天本來想跳戰線上課程的練習專案的，但是體力有點耗盡了，因此我只先創建了一個新的專案。明天再來繼續挑戰。\nnpx create-react-app practice-project  2022/06/29 今天上班處理了關於時間的問題，date-fns不管怎麼樣使用format，時間都會相差8小時，後來未來即時解決問題我決定暫時先自行處理，使用Date物件拿到年、月、日、時、分、秒，再加上zero pad換成想要的格式。\n2022/07/02 由於每次接到API資料的時候總覺得，自己重新產生想要的資料總是會重複做很多次一樣的步驟才達成目標，讓我有了想要學習資料結構的心，因此我開始學習了資料結構。\nData structure Linked List(鏈結串列) 一般來說，產生陣列必須要先指定陣列長度。\nString[] myArr = new String[10];  記憶體會找一個地方，留10個連續的記憶體空間使用。\n而Linked List在記憶體上不一定會是連續的位置。 Linked List只包含head和length兩個property。\n Linked List Advantage 可以不斷加入element，無限制次數。反之，array則會要調整長度 加入element的速度很快。 在js中如果指定一個空陣列，一開始給的長度會是1，接著根據加入array的元素才會不斷增加記憶體位置來儲存，從1開始2,4,8,16\u0026hellip;，需要不斷的去更改記憶體分配。 Linked List要更改，例如刪除，只需要將指向下一個head的pointer跳過刪除的元素到下一個就完成了。而Array在刪除某個元素之後必須將之後的元素全部的都往前移。  javascript寫出Linked List // 每一個Linked List裡的元素,會有元素的value，以及指向下一個元素。 class Node { constructor(value) { this.value = value; this.next = null; } } // 整個LinkedList只有兩個property，一個是head，一個是長度，一開始沒有長度，也沒有head class LinkedList { constructor() { this.head = null; this.length = 0; } // 新增元素進入Linked List的最後面 push(value) { let newNode = new Node(value); // Linked List起頭要是沒有東西的話則為鏈結串列的第一個元素 if(this.head === null) { this.head = newNode; } else { // 現在的Node會等於第一個head let currentNode = this.head; //往下一個找 只要有指向另外一個元素 while(currentNode.next !== null) { currentNode = currentNode.next; } // 找到最後一個只後currentNode.next === null給新的值 currentNode.next = newNode; } this.length++; } printAll() { if(this.length === 0) { console.log('Nothing in this LinkedList!'); return; } let currentNode = this.head; while(currentNode !== null) { console.log(currentNode.value); currentNode = currentNode.next; } } } let myLinkedList = new LinkedList(); myLinkedList.push(\u0026quot;Wyatt\u0026quot;); myLinkedList.push(\u0026quot;Wayne\u0026quot;); myLinkedList.push(\u0026quot;Kuang\u0026quot;); myLinkedList.printAll(); console.log(myLinkedList);  MongoDB NoSQL的特性\n No data schema(資料表及欄位的設計) Fewer Data Realation  MongoDB的使用 npm install mongodb  連接MongoDb // database.js const mongodb = require(\u0026quot;mongodb\u0026quot;); const MongoClient = mongodb.MongoClient; let _db; // 底線代表只想在這個文件內部讀取到 const mongoConnect = () =\u0026gt; { MongoClient.connect( \u0026quot;mongodb+srv://\u0026lt;使用者名稱\u0026gt;:\u0026lt;使用者密碼\u0026gt;@cluster0.ykhk6.mongodb.net/shop?retryWrites=true\u0026amp;w=majority\u0026quot; ) .then((client) =\u0026gt; { _db = client.db(); // 可以跟database互動 }) .catch((err) =\u0026gt; { throw err; }) } const getDb = () =\u0026gt; { if(_db) { return _db; } throw \u0026quot;No database Found!\u0026quot; } exports.mongoConnect = mongoConnect; exports.getDb = getDb;  db的各種操作  創建collections，新增一比資料。  const mongodb = require(\u0026quot;mongodb\u0026quot;); const getDb = require(\u0026quot;../util/database\u0026quot;).getDb; // 會自動新增products collection，新增一筆資料user資料 const db = getDb(); db.collection('products') .insertOne({ username: \u0026quot;wyatt\u0026quot;, email: \u0026quot;test@gmail.com\u0026quot;, id: new mongodb.ObjectId(id) // 主要是使用mongodb產生的id物件 })  查找一筆資料 拿課程中部份程式做紀錄，使用find({key: 條件})，物件裡面第一個是找到的key，第二個是要寫符合的條件。  $in是特別用法會將所有我們提供javascript陣列的字串，查詢是否有符合的條件，並且使用toArray()，拿到所有的資料並轉換成陣列可以使用。\n這裡要特別注意的是我們拿到的new ObjectId雖然是一個物件，雖然看上去一樣，但在使用===類型檢測上會不一樣，所以記得要使用.toString()\ngetCart() { const db = getDb(); const productIds = this.cart.items.map((i) =\u0026gt; { return i.productId; }); return db .collection(\u0026quot;products\u0026quot;) .find({ _id: { $in: productIds } }) // 主要是這裡 .toArray() .then((products) =\u0026gt; { return products.map((p) =\u0026gt; { return { ...p, quantity: this.cart.items.find((i) =\u0026gt; { return i.productId.toString() === p._id.toString(); }).quantity, }; }); }); }  更新一比資料 更新資料也很簡單，db.collection(\u0026ldquo;users\u0026rdquo;).updateOne({},{})， 第一個參數填入要改的資料，第二個使用$set可以指定要改的欄位的value。  const updatedCart = { items: updatedCartItems }; const db = getDb(); return db .collection(\u0026quot;users\u0026quot;) .updateOne( { _id: new ObjectId(this._id) }, { $set: { cart: updatedCart } } );  刪除一筆資料 可以使用update把資料清空。  ","id":1,"section":"posts","summary":"I/O (2022/06/27 - 2022/07/01) 每天記錄每天學到什麼，主要是因為這樣子才能及時的輸出，發現要寫長文對自己來說太困難了。而且覺得效率也是一個問題，想要先累積出一些作品","tags":["TypeScript","React","Data structure","MongoDB"],"title":"I/O (2022/06/27 - 2022/07/01)","uri":"https://hungchang.co/2022/06/inputoutput2022-06-27/","year":"2022"},{"content":"Javascript-原型鏈 Javascript中除了純值之外，剩下的類型其實都是物件，每個物件除了頂層的物件中都有原型，在ECMAScript標準裡面是寫成someObj.[[Prototype]]。\n在瀏覽器中我們常會用.__proto__取得當前物件的原型物件，要注意的是.__proto__是瀏覽器實做訪問原型的方便寫法，正式的讀寫應該使用 Object.getPrototypeOf(someObj) 以及 Object.setPrototypeOf() 這兩個訪問器。但是為了理解，這裡講都會使用.__proto__來做筆記。\n訪問原型鏈 當我們對於一個物件查找屬性找不到時，JS會往原型物件找。\nvar person = { name: \u0026quot;ZZ\u0026quot;, age: 24 } person.__proto__.height = 1.65 console.log(person.height) // 1.65  原本應該沒有height屬性，但在person物件的原型物件上加上屬性後便會從person往上找person.__proto__找有沒有height屬性，將結果輸出。\n然而\n參考連結 MDN\n","id":2,"section":"posts","summary":"Javascript-原型鏈 Javascript中除了純值之外，剩下的類型其實都是物件，每個物件除了頂層的物件中都有原型，在ECMAScri","tags":["Javascript"],"title":"Javascript-原型鏈","uri":"https://hungchang.co/2022/05/javascript-prototype-chain/","year":"2022"},{"content":"React 下載  下載node 下載react  npx create-react-app my-app cd my-app npm start  閱讀官方docs後的心得 以資料結構想畫面，盡量讓資料結構跟畫面能夠結合在一起。 操控資料要使用useState import { useState } from 'react'; const [inputText, setInputText] = useState(\u0026quot;init word\u0026quot;)  useState會回傳一個陣列，陣列的第一個是變數，第二個則是操縱資料變化的函數，其命名方法會是一個名詞，另一個是 “set名詞” 。一開始useState裡要傳入初始化的數值當作參數。\n inputText 值只會被初始化一次。\n React要做到雙向綁定(資料綁畫面，畫面改動寫回資料)需要手動調用useState的第二個函數。 操作資料一定要使用setInputText，不可以直接賦值變數。\n如果資料是由父傳子，想要改變狀態可以將setInputText()當成props傳下去。 並且傳下去的名稱會使用 on + 名詞 + 操作動作，如同onInputTextChange\n細部探討 - Component 每一個物件都是一個function，並且回傳jsx。使用export可以導出元件，在其他文件導入來複用。\n一個文件export default 只能有一個，但可以有多個export。導入方式根據是不是default有所不同。\n// a.js export default function Profile(){...} export function Other1() {...} export function Other2() {...} // b.js import Profile from './a.js' import { Other1, Other2 } from './a.js'   要注意react的function名稱一定是要大寫開頭命名才會有作用。主要是因為要區分是html的tag還是是react的component.\n 細部探討 - export 和 import 在react的專案中，src/App.js是app的根。除非是用Next.js，它的每個頁面的跟才會不一樣。\n在import的時候可以不加副檔名.js，這是因為es module的特性。\n細部探討 - JSX 在撰寫JSX的時候有些地方與html不一樣。下面條列規則\n 必須只有一個根包住整個結構，可以用，也可以使用\u0026lt;\u0026gt;\u0026lt;/\u0026gt;  \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;JSX\u0026lt;/h1\u0026gt; \u0026lt;img\u0026gt; \u0026lt;/div\u0026gt;  \u0026lt;\u0026gt; \u0026lt;h1\u0026gt;JSX\u0026lt;/h1\u0026gt; \u0026lt;img\u0026gt; \u0026lt;/\u0026gt;  這個\u0026lt;\u0026gt;\u0026lt;/\u0026gt;特別的tag叫做React fragment。不能夠有兩個以上的root是因為jsx最終都會被轉成js物件，一個function裡不能同時兩個物件在沒有展開的情況下。\n","id":3,"section":"posts","summary":"React 下載 下載node 下載react npx create-react-app my-app cd my-app npm start 閱讀官方docs後的心得 以資料結構想畫面，盡量讓資料結構跟畫面能夠結合在一起。 操控資料要使用u","tags":["React"],"title":"React初體驗","uri":"https://hungchang.co/2022/05/react/","year":"2022"},{"content":"創建一個Https伺服器 首先我們要先產生一個憑證\nopenssl req -newkey rsa:2048 -nodes -keyout server.key -x509 -days 365 -out server.crt  接著打上以下的程式碼\n// https.go package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; ) func main() { srv := \u0026amp;http.Server{Addr: \u0026quot;:9001\u0026quot;, Handler: http.HandlerFunc(handle)} log.Printf(\u0026quot;Serving on http://0.0.0.0:9001\u0026quot;) log.Fatal(srv.ListenAndServeTLS(\u0026quot;server.crt\u0026quot;, \u0026quot;server.key\u0026quot;)) } func handle(w http.ResponseWriter, r *http.Request) { log.Printf(\u0026quot;Got connection: %s\u0026quot;, r.Proto) w.Write([]byte(\u0026quot;Hello, this is a HTTP 2 message\u0026quot;)); }  在瀏覽器打上https://0.0.0.0:9001便可以看到\u0026quot;Hello, this is a HTTP 2 message\u0026quot;\n","id":4,"section":"posts","summary":"創建一個Https伺服器 首先我們要先產生一個憑證 openssl req -newkey rsa:2048 -nodes -keyout server.key -x509 -days 365 -out server.crt 接著打上以下的程式碼 // https.go package main import ( \u0026quot;log\u0026quot; \u0026quot;net/http\u0026quot; ) func main() { srv := \u0026amp;http.Server{Addr: \u0026quot;:9001\u0026quot;, Handler: http.HandlerFunc(handle)} log.Printf(\u0026quot;Serving on http://0.0.0.0:9001\u0026quot;) log.Fatal(srv.ListenAndServeTLS(\u0026quot;server.crt\u0026quot;, \u0026quot;server.key\u0026quot;)) }","tags":["Go"],"title":"Go-net/HTTP創建伺服器","uri":"https://hungchang.co/2022/05/go-nethttp/","year":"2022"},{"content":"初學TypeScript 原本想用Go學習後端，但是大家建議先學好TS並且加上Node.js練習，等到熟悉了再學習Go，加上工作剛好\n未來有需求要使用TypeScript，因此我來學習TypeScript了。網路上找到覺得最好的教學就是由Maxwell\n寫的文章，寫得相當詳細，我還買了他的書來詳讀。本篇文章都是拜讀書籍的內容，強烈建議大家購買。\n附上連結讓 TypeScript 成為你全端開發的 ACE！系列，作者：Maxwell\nTS的原始型別 Primitive Types js的原始型別有number, string, boolean, undefined, null, void\nlet num = 123; let message = 'Hello world'; let truthy = true; let meansEmpty = undefined; // any let meansNothing = null; // any  這裡直接賦值undefined和null不是好事情因此我們必須型別註記一下。\nlet meansEmpty: undefined = undefined; let meansNothing: null = null;  遲滯性指派Delayed Initialization 當我們一開始宣告一個變數，卻沒有賦予值的時候，TypeScript也會把變數當成any。\nlet num; // any console.log(num); // undefined num = 123;  上面的例子並不會報錯，因為num被判別成any的緣故，這顯然很糟糕。因此我們必須一開始型別註記避免發生 沒有預期的錯誤。\nlet num:number; console.log(num); // 報錯  let num:number | undefined; console.log(num) // 不會報錯  JSON物件的型別 物件的型別註記長得像下面一樣\nlet info : { name: string; age: number; interest: string[]; } = { name: 'wyatt', age: 24, interest: ['drawing', 'programming'] }  只是上面看起來實在是太複雜了，因此我們把物件結構抽出來。這裡可以使用\u0026quot;型別化名\u0026quot;簡潔程式，型別化名 可以抽象化。\ntype PersonalInfo = { name: string; age: number; interest: string[]; } let info: PersonalInfo = { name: 'Wyatt', age: 24, interest: ['programming', 'play game'] }  物件的完整性 物件不可以隨便新增及刪除，並且更改值必須符合物件結構的型別。\ninfo.email = 'test@gmail.com' // 報錯 delete info.name; // 也會報錯了 info.name = 'Wayne' // 這種複寫因為型別一樣可以  全部複寫是可以的，但還是一樣要符合型別\ninfo = { name: \u0026quot;Wayne\u0026quot;, age: info.age, interest: info.interest, } // ES7(Rest-Spread Operator)寫法 info = {...info, name: 'Wayne'} info = {...info, name: 123} // 報錯，string不可以賦值number  唯獨屬性 我們有時候會希望物件不可以被覆寫，可以使用readonly。\ntype PersonalInfo = { name: string, readonly age: number; interest: string[]; } let info: PersonalInfo = { name: \u0026quot;wyatt\u0026quot;, age: 24, interest: [\u0026quot;programming\u0026quot;] } info.age = 25; // 報錯，因為readonly  有時候我們是引用別人寫的程式，為了避免型別化名的自由度降低，但避免物件太過自由的方法可以用下面的 方法。\ntype PersonalInfo = { name: string; age: number; interest: string[]; } let info: Readonly\u0026lt;PersonalInfo\u0026gt; = { name: \u0026quot;wyatt\u0026quot;, age: 24, interest: [\u0026quot;programming\u0026quot;] } info.age = 25; // 也會報錯  函式的型別 大多函數的參數都會被判別成any，因此涵式的輸入都必須要進行註記的動作\n 宣告變數，將函數當成物件值  let addition1: (a: number, b: number) =\u0026gt; number = function(a, b) { return a + b; }  宣告變數，將函數當成物件值，在韓式宣告輸入輸出時，一併註記。  let addition2 = function (a: number, b: number): number { return a + b; }  函數宣告，輸入、輸出時註記  function addition3(a: number, b: number): number { return a + b }  函數物件值屬於表達式，使用斷言註記法  let addition4 = function(a, b) { return a + b } as (a: number, b: number) =\u0026gt; number;  選用參數 - 只能在參數的尾端 // ok function sumFrom3Nums(input1: number, input2?: number, input3?: number) { return input1 + (input2 ? input2 : 0) + (input3 ? input3 : 0); } // 不ok function sumFrom3Nums(input1: number, input2?: number, input3: number) { return input1 + (input2 ? input2 : 0) + (input3 ? input3 : 0); }  預設參數 使用空值連結操作符(Nullish Coalescing Operator)\nfunction increment(input1: number, input2?:number) { const value = input2 ?? 1; return input1 + value }  通常我們會寫成下面這樣\nfunction increment(input1: number, input2: number = 1) { return input1 + input2 }  陣列型別 二維陣列\nconst points = [ [1, 2, 3], [4, 5, 6], [7, 8, 9] ] // 型別判別是int[][]  如果想在陣列裡放速不同型態的可以寫成下面的樣子(要注意括號要加)\nconst arr1: (number | string)[] = [1, 2, 3]; const arr2: number | string[] = [1, 2, 3]; // 這個意思是數字或是字串型別陣列，會報錯  明文類別 使用let宣告變數並指派原始型別的值，被推論的不是明文型別，而是明文代表的型別。\n使用const則選告變數是指派原始型別值， 並且被推論的是明文型別。\n以下是純值的型別註記\nlet jsonObj: { foo: 123, bar: \u0026quot;Hello\u0026quot; } = { foo: 123, bar: \u0026quot;Hello\u0026quot; }; jsonObj.foo = 123; jsonObj.foo = 456; 不行，會報錯  ","id":5,"section":"posts","summary":"初學TypeScript 原本想用Go學習後端，但是大家建議先學好TS並且加上Node.js練習，等到熟悉了再學習Go，加上工作剛好 未來有需求","tags":["TypeScript"],"title":"TypeScript","uri":"https://hungchang.co/2022/05/typescriptbasic/","year":"2022"},{"content":"初學Node HTTP,HTTPS 超文本傳輸協定，瀏覽器與伺服器交換資料的協定。\n Http: Hyper Text Transfer Protocol Https: Hyper Text Transfer Protocol Secure。 HTTP + Data Encryption (during Transmission)。  Node創建一個簡單的伺服器 app.js\nconst http = require('http') function requestHandler(req, res, next) =\u0026gt; { console.log(req.url, req.method, req.headers); // process.exit() // 這樣寫會結束程式 next(); // 這裡的next是一個函數，代表讓城市繼續進行下去，前往下一個中間件。 } const server = http.createServer(requestHandler) // 這裡NodeJS會一直監聽有沒有request server.listen(3000); // server監聽port3000  當我們node.js app.js後，會開始解析程式，編譯之後註冊變數和函數，接著js引擎提供event loop，會持續\n等待event listener註冊，直到行程結束(這裡是指app.js程式結束才會結束)。\n分離路徑 通常網頁會有不同的請求，通通把所有request判斷都寫在app.js會相當複雜不易閱讀，因此我們通常會根據不同功能拆分路徑。\n在根目錄下底下創建 routes.js，把我們剛才的requestHandler分離出去。\nconst fs = require(\u0026quot;fs\u0026quot;); // node的資料夾裡的file system const requestHandler = (req, res) =\u0026gt; { // * sending response const url = req.url; // 我們取得了使用者輸入的url const method = req.method; // 使用者使用的請求方式(GET? POST?...) if (url === \u0026quot;/\u0026quot;) { res.write(\u0026quot;\u0026lt;html\u0026gt;\u0026quot;); res.write(\u0026quot;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Enter Message\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026quot;); res.write( '\u0026lt;body\u0026gt;\u0026lt;form action=\u0026quot;/message\u0026quot; method=\u0026quot;POST\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;message\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Send\u0026lt;/button\u0026gt;\u0026lt;/form\u0026gt;\u0026lt;/body\u0026gt;' ); res.write(\u0026quot;\u0026lt;/html\u0026gt;\u0026quot;); return res.end(); //結束傳送資料給客戶端，不繼續執行下去，後面不會繼續執行下去，因此我們在這裡return } if (url === \u0026quot;/message\u0026quot; \u0026amp;\u0026amp; method === \u0026quot;POST\u0026quot;) { const body = []; req.on(\u0026quot;data\u0026quot;, (chunk) =\u0026gt; { console.log(chunk); body.push(chunk); }); return req.on(\u0026quot;end\u0026quot;, () =\u0026gt; { const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split(\u0026quot;=\u0026quot;)[1]; console.log(parsedBody); fs.writeFile(\u0026quot;message.txt\u0026quot;, message, (err) =\u0026gt; { res.statusCode = 302; res.setHeader(\u0026quot;Location\u0026quot;, \u0026quot;/\u0026quot;); return res.end(); }); }); } res.setHeader(\u0026quot;Content-Type\u0026quot;, \u0026quot;text/html\u0026quot;); res.write(\u0026quot;\u0026lt;html\u0026gt;\u0026quot;); res.write(\u0026quot;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;My First Page\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026quot;); res.write(\u0026quot;\u0026lt;body\u0026gt;\u0026lt;h1\u0026gt;Hello from my Node.js Server!\u0026lt;/h1\u0026gt;\u0026lt;/body\u0026gt;\u0026quot;); res.write(\u0026quot;\u0026lt;/html\u0026gt;\u0026quot;); res.end(); //結束傳送資料給客戶端 }; module.exports = requestHandler exports.handler = requestHandler; exports.someText = 'Some hard coded text'  上面的程式碼分段解釋\nconst url = req.url; // 我們取得了使用者輸入的url const method = req.method; // 使用者使用的請求方式(GET? POST?...) if (url === \u0026quot;/\u0026quot;) { res.write(\u0026quot;\u0026lt;html\u0026gt;\u0026quot;); res.write(\u0026quot;\u0026lt;head\u0026gt;\u0026lt;title\u0026gt;Enter Message\u0026lt;/title\u0026gt;\u0026lt;/head\u0026gt;\u0026quot;); res.write( '\u0026lt;body\u0026gt;\u0026lt;form action=\u0026quot;/message\u0026quot; method=\u0026quot;POST\u0026quot;\u0026gt;\u0026lt;input type=\u0026quot;text\u0026quot; name=\u0026quot;message\u0026quot;\u0026gt;\u0026lt;button type=\u0026quot;submit\u0026quot;\u0026gt;Send\u0026lt;/button\u0026gt;\u0026lt;/form\u0026gt;\u0026lt;/body\u0026gt;' ); res.write(\u0026quot;\u0026lt;/html\u0026gt;\u0026quot;); return res.end(); //結束傳送資料給客戶端，不繼續執行下去，後面不會繼續執行下去，因此我們在這裡return }  這裡當我們輸入http://localhost:3000/，會得到上面回傳的表單，裡面可以輸入資料並且POST到路徑/message。\nif (url === \u0026quot;/message\u0026quot; \u0026amp;\u0026amp; method === \u0026quot;POST\u0026quot;) { const body = []; req.on(\u0026quot;data\u0026quot;, (chunk) =\u0026gt; { console.log(chunk); body.push(chunk); }); return req.on(\u0026quot;end\u0026quot;, () =\u0026gt; { const parsedBody = Buffer.concat(body).toString(); const message = parsedBody.split(\u0026quot;=\u0026quot;)[1]; console.log(parsedBody); fs.writeFile(\u0026quot;message.txt\u0026quot;, message, (err) =\u0026gt; { res.statusCode = 302; res.setHeader(\u0026quot;Location\u0026quot;, \u0026quot;/\u0026quot;); return res.end(); }); }); }  當我們POST到/message後便會符合路徑url === \u0026lsquo;message\u0026rsquo;和 method === \u0026lsquo;POST\u0026rsquo;，\n這裡我們寫上req.on(\u0026lsquo;data\u0026rsquo;)代表監聽傳來的資料，這裡有一個要補充的知識就是Buffer， 在接受傳輸的資料時候，伺服器會將一整個資料流(stream)分成好幾塊(chunk)接受，完成後再拼接一起轉換成可讀的資料。  這裡這張圖並不是Node.js運行的樣子，只是為了說明資料會像這樣分成好幾塊。\n 等到所有的資料都接收到，便會呼叫req.on(\u0026ldquo;end\u0026rdquo;,()=\u0026gt; {/執行這裡的程式/})\n我們便可以調用Buffer.concat()的方法把資料串起來，並且轉換成字串。\n最後我們在使用fs.writeFile來寫入檔案，並且給http狀態碼302(轉址)，將頁面轉回原來的表單頁面。\n結論 我們可以發現因為js引擎是single thread也就是說一次只做一件事，如果今天有一個檔案很大，某個使用者請求了，\n那樣程式就會在原地等待讀取檔案結束才繼續進行下去。那樣另外一個使用者也發起同樣的請求，他便會需要等到前面的\n使用者請求完成才可以繼續處理該名使用者的請求，這相當不合理。因此我們的function就必須要是非同步的，\n當我們有請求的時候，將處理交給額外的worker pool，等到處理完的時候，便通知event loop裡面註冊的listener，\n去執行裡面的回調函數來處理接下來的步驟。\n","id":6,"section":"posts","summary":"初學Node HTTP,HTTPS 超文本傳輸協定，瀏覽器與伺服器交換資料的協定。 Http: Hyper Text Transfer Protocol Https: Hyper Text Transfer Protocol Secure。 HTTP + Data Encryption (during Transmission)。 Node","tags":["Node"],"title":"Node學習-Server、Stream/Buffer","uri":"https://hungchang.co/2022/05/nodestarter/","year":"2022"},{"content":"Node模組-path Node讀取資料夾及文件的路徑經常使用的。\nresolve使用: path.resolve const path = require('path'); const basePath = '\\\\User\\\\Wyatt'; const filename = 'test.txt'; // const filePath = basePath + '/' + filename; //使用拼接會有路徑問題 /* 註釋 每個系統使用的路徑分隔符號不一樣 Linux / Mac os / Window \\, \\\\, / IEEE提出可疑值操作系統接口(Portable Operating System Interface，縮寫POSIX) Linux和Mac OS都實現了POSIX接口 Windows電腦的話是部分實現POSIX接口 */ const filePath = path.resolve(basePath, filename) // 這裡會幫我們處理basePath裡面路徑的分割符號 console.log(filePath) // D:\\User\\Wyatt\\test.txt  獲得路徑的資訊: path.xxx const path = require('path'); // 1.獲取路徑訊息 const filepath = '/User/Wyatt/test.txt' console.log(path.dirname(filepath)); // /User/Wyatt console.log(path.basename(filepath)); // test.txt console.log(path.extname(filepath)); // .txt  路徑的拼接: join和resolve的不同 // 2. join拼接 const basepath = '../User/Wyatt'; const filename = 'test.txt'; const filepath = path.join(basepath, filename); console.log(filepath) // ..\\User\\Wyatt\\test.txt // 3. resolve拼接 // resolve會判斷拼接的路徑中，是否有以/或./或../開頭的路徑 const filepath2 = path.resolve(basepath, filename); console.log(filepath2) // D:\\Node\\05_常見的模組\\User\\Wyatt\\test.txt  ","id":7,"section":"posts","summary":"Node模組-path Node讀取資料夾及文件的路徑經常使用的。 resolve使用: path.resolve const path = require('path'); const basePath = '\\\\User\\\\Wyatt'; const filename = 'test.txt'; // const filePath = basePath + '/' + filename; //使用拼接","tags":["Node"],"title":"Node模組-path","uri":"https://hungchang.co/2022/05/node-path/","year":"2022"},{"content":" 全文皆來自自學Youtube的教學影片Learn Go Programming - Golang Tutorial for Beginners，講得相當好，大家可以點進去學習。\n Array array是一個固定長度的資料且並非指標的值，在Go中array只能裝同樣類型的資料。\n Array各種聲明方法，要注意只能裝同個類型。  package main import ( \u0026quot;fmt\u0026quot; ) func main() { // 三種聲明array的方式 grades := [3]{12, 55, 77} points := [...]{23, 55, 77} // 會自動偵測元素有多少個來決定長度 var students [3]string // 我們可以更換array的值 students[0] = \u0026quot;Wyatt\u0026quot; students[1] = \u0026quot;Wayne\u0026quot; students[2] = \u0026quot;Peter\u0026quot; fmt.Printf(\u0026quot;Grades: %v\\n\u0026quot;, grades) fmt.Printf(\u0026quot;Students: %v\u0026quot;, students) // 我們可以用len()來取得 fmt.Printf(\u0026quot;Numbers of Student:\u0026quot;, len(students)) }  可以創建一個多維的陣列  package main import ( \u0026quot;fmt\u0026quot; ) func main() { var matrix [3][3]int = [3][3]{[3]int{1, 0, 0}, [3]int{0, 1, 0}, [3]int{0, 0, 1}} // 上面很複雜，可以用下面的方法比較清楚 var identityMatrix [3][3]int identityMatrix[0] = [3]int{1, 0, 0} identityMatrix[1] = [3]int{0, 1, 0} identityMatrix[2] = [3]int{0, 0, 1} fmt.Println(identityMatrix) // [[1 0 0] [0 1 0] [0 0 1]] }  以下例子可以證明陣列Array並非指標  a := [...]int{1, 2, 3} b := a b[1] = 5 c := \u0026amp;a // 表示我要指向a的記憶體值 fmt.Println(a) [1, 2, 3] fmt.Println(b) [1, 5, 3] fmt.Println(c) \u0026amp;[1, 2, 3]  由上述例子可以知道b是直接複製a的值到新的記憶體空間，並非複製a指向記憶體的指針。\n","id":8,"section":"posts","summary":"全文皆來自自學Youtube的教學影片Learn Go Programming - Golang Tutorial for Beginners，講得相當好，大家可以點進去學習。 Array array是一個固定長度的","tags":["Go"],"title":"array","uri":"https://hungchang.co/2022/05/array/","year":"2022"},{"content":"struct struct類型 struct就很像是類的概念\npackage main import \u0026quot;fmt\u0026quot; func main() { type game struct { name string stars int category []string } fallguys := game{name: \u0026quot;fallguys\u0026quot;} // 第一種賦值方法 fallguys = game{ name: \u0026quot;糖豆人\u0026quot;, stars: 5.0, category: []string{\u0026quot;funny\u0026quot;}, } // 第二種賦值方法 fallguys = game{\u0026quot;糖豆人\u0026quot;, 5.0, []string{\u0026quot;funny\u0026quot;}} fmt.Println(fallguys) //{糖豆人 5 [funny]} fmt.Println(fallguys.stars) // 5 fmt.Println(fallguys.category) // [funny] fallguys.stars ++ fmt.Println(fallguys.stars) // 6 fallguys.category = append(fallguys.category, \u0026quot;children\u0026quot;) // [funny children] fmt.Println(fallguys.category) type platform struct { name string game game } steam := platform{ name: \u0026quot;steam\u0026quot;, game: fallguys, } fmt.Println(steam) // {steam {糖豆人 6 [funny children]}} fmt.Println(steam.game.stars) // 6 steam.game.stars = 4 fmt.Println(steam.game.stars) // 4 fmt.Println(fallguys.stars) // 6 不會改變，因為steam.game.stars這裡給的是copy的值 type addressSteam struct { name string game *game // 這裡是一個傳入一個參考的值，等等創建struct就會直接傳入參考struct的位置，而非在複製一分資料。 } addressed := addressSteam{\u0026quot;Addressed Steam\u0026quot;, \u0026amp;fallguys} // 這裡給的就是指向fallguys的位置 fmt.Println(addressed) fmt.Println(*addressed.game) addressed.game.stars = 4 fmt.Println(addressed.game.stars) //4 這裡的game指向 fallguys fmt.Println(fallguys.stars) // 4 LOL := new(game) fmt.Println(LOL) // \u0026amp;{ 0 []} fmt.Println(*LOL) // { 0 []} (*LOL).name = \u0026quot;LOL\u0026quot; // 實際上看起來是這樣，但是golang幫忙解決了 LOL.category = []string{\u0026quot;dota\u0026quot;} LOL.stars= 4 intel := cpu{name: \u0026quot;intel\u0026quot;, speed: 100} intel.getPrice() intel.getSpeed() } type cpu struct { name string speed float64 } func (cpu) getPrice() { fmt.Println(\u0026quot;get total price\u0026quot;) } // 像是往cpu這個類別加了一個方法 func (c cpu) getSpeed() { fmt.Println(c.speed) } // 第一個參數是receiver的概念，在Go中稱之為method  ","id":9,"section":"posts","summary":"struct struct類型 struct就很像是類的概念 package main import \u0026quot;fmt\u0026quot; func main() { type game struct { name string stars int category []string } fallguys := game{name: \u0026quot;fallguys\u0026quot;} // 第一種賦值方法 fallguys = game{ name: \u0026quot;糖豆人\u0026quo","tags":["Go"],"title":"struct","uri":"https://hungchang.co/2022/05/struct/","year":"2022"}],"tags":[{"title":"Data structure","uri":"https://hungchang.co/tags/data-structure/"},{"title":"Go","uri":"https://hungchang.co/tags/go/"},{"title":"JavaScript","uri":"https://hungchang.co/tags/javascript/"},{"title":"MongoDB","uri":"https://hungchang.co/tags/mongodb/"},{"title":"Node","uri":"https://hungchang.co/tags/node/"},{"title":"Node.js","uri":"https://hungchang.co/tags/node.js/"},{"title":"React","uri":"https://hungchang.co/tags/react/"},{"title":"TypeScript","uri":"https://hungchang.co/tags/typescript/"}]}