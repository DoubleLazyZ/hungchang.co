{"categories":[{"title":"Go","uri":"https://hungchang.co/categories/go/"},{"title":"Node","uri":"https://hungchang.co/categories/node/"}],"posts":[{"content":"Node模組-path Node讀取資料夾及文件的路徑經常使用的。\nresolve使用: path.resolve const path = require('path'); const basePath = '\\\\User\\\\Wyatt'; const filename = 'test.txt'; // const filePath = basePath + '/' + filename; //使用拼接會有路徑問題 /* 註釋 每個系統使用的路徑分隔符號不一樣 Linux / Mac os / Window \\, \\\\, / IEEE提出可疑值操作系統接口(Portable Operating System Interface，縮寫POSIX) Linux和Mac OS都實現了POSIX接口 Windows電腦的話是部分實現POSIX接口 */ const filePath = path.resolve(basePath, filename) // 這裡會幫我們處理basePath裡面路徑的分割符號 console.log(filePath) // D:\\User\\Wyatt\\test.txt  獲得路徑的資訊: path.xxx const path = require('path'); // 1.獲取路徑訊息 const filepath = '/User/Wyatt/test.txt' console.log(path.dirname(filepath)); // /User/Wyatt console.log(path.basename(filepath)); // test.txt console.log(path.extname(filepath)); // .txt  路徑的拼接: join和resolve的不同 // 2. join拼接 const basepath = '../User/Wyatt'; const filename = 'test.txt'; const filepath = path.join(basepath, filename); console.log(filepath) // ..\\User\\Wyatt\\test.txt // 3. resolve拼接 // resolve會判斷拼接的路徑中，是否有以/或./或../開頭的路徑 const filepath2 = path.resolve(basepath, filename); console.log(filepath2) // D:\\Node\\05_常見的模組\\User\\Wyatt\\test.txt  ","id":0,"section":"posts","summary":"Node模組-path Node讀取資料夾及文件的路徑經常使用的。 resolve使用: path.resolve const path = require('path'); const basePath = '\\\\User\\\\Wyatt'; const filename = 'test.txt'; // const filePath = basePath + '/' + filename; //使用拼接","tags":["Node"],"title":"Node模組-path","uri":"https://hungchang.co/2022/05/node-path/","year":"2022"},{"content":" 全文皆來自自學Youtube的教學影片Learn Go Programming - Golang Tutorial for Beginners，講得相當好，大家可以點進去學習。\n Array array是一個固定長度的資料且並非指標的值，在Go中array只能裝同樣類型的資料。\n Array各種聲明方法，要注意只能裝同個類型。  package main import ( \u0026quot;fmt\u0026quot; ) func main() { // 三種聲明array的方式 grades := [3]{12, 55, 77} points := [...]{23, 55, 77} // 會自動偵測元素有多少個來決定長度 var students [3]string // 我們可以更換array的值 students[0] = \u0026quot;Wyatt\u0026quot; students[1] = \u0026quot;Wayne\u0026quot; students[2] = \u0026quot;Peter\u0026quot; fmt.Printf(\u0026quot;Grades: %v\\n\u0026quot;, grades) fmt.Printf(\u0026quot;Students: %v\u0026quot;, students) // 我們可以用len()來取得 fmt.Printf(\u0026quot;Numbers of Student:\u0026quot;, len(students)) }  可以創建一個多維的陣列  package main import ( \u0026quot;fmt\u0026quot; ) func main() { var matrix [3][3]int = [3][3]{[3]int{1, 0, 0}, [3]int{0, 1, 0}, [3]int{0, 0, 1}} // 上面很複雜，可以用下面的方法比較清楚 var identityMatrix [3][3]int identityMatrix[0] = [3]int{1, 0, 0} identityMatrix[1] = [3]int{0, 1, 0} identityMatrix[2] = [3]int{0, 0, 1} fmt.Println(identityMatrix) // [[1 0 0] [0 1 0] [0 0 1]] }  以下例子可以證明陣列Array並非指標  a := [...]int{1, 2, 3} b := a b[1] = 5 c := \u0026amp;a // 表示我要指向a的記憶體值 fmt.Println(a) [1, 2, 3] fmt.Println(b) [1, 5, 3] fmt.Println(c) \u0026amp;[1, 2, 3]  由上述例子可以知道b是直接複製a的值到新的記憶體空間，並非複製a指向記憶體的指針。\n","id":1,"section":"posts","summary":"全文皆來自自學Youtube的教學影片Learn Go Programming - Golang Tutorial for Beginners，講得相當好，大家可以點進去學習。 Array array是一個固定長度的","tags":["Go"],"title":"array","uri":"https://hungchang.co/2022/05/array/","year":"2022"},{"content":"struct struct類型 struct就很像是類的概念\npackage main import \u0026quot;fmt\u0026quot; func main() { type game struct { name string stars int category []string } fallguys := game{name: \u0026quot;fallguys\u0026quot;} // 第一種賦值方法 fallguys = game{ name: \u0026quot;糖豆人\u0026quot;, stars: 5.0, category: []string{\u0026quot;funny\u0026quot;}, } // 第二種賦值方法 fallguys = game{\u0026quot;糖豆人\u0026quot;, 5.0, []string{\u0026quot;funny\u0026quot;}} fmt.Println(fallguys) //{糖豆人 5 [funny]} fmt.Println(fallguys.stars) // 5 fmt.Println(fallguys.category) // [funny] fallguys.stars ++ fmt.Println(fallguys.stars) // 6 fallguys.category = append(fallguys.category, \u0026quot;children\u0026quot;) // [funny children] fmt.Println(fallguys.category) type platform struct { name string game game } steam := platform{ name: \u0026quot;steam\u0026quot;, game: fallguys, } fmt.Println(steam) // {steam {糖豆人 6 [funny children]}} fmt.Println(steam.game.stars) // 6 steam.game.stars = 4 fmt.Println(steam.game.stars) // 4 fmt.Println(fallguys.stars) // 6 不會改變，因為steam.game.stars這裡給的是copy的值 type addressSteam struct { name string game *game // 這裡是一個傳入一個參考的值，等等創建struct就會直接傳入參考struct的位置，而非在複製一分資料。 } addressed := addressSteam{\u0026quot;Addressed Steam\u0026quot;, \u0026amp;fallguys} // 這裡給的就是指向fallguys的位置 fmt.Println(addressed) fmt.Println(*addressed.game) addressed.game.stars = 4 fmt.Println(addressed.game.stars) //4 這裡的game指向 fallguys fmt.Println(fallguys.stars) // 4 LOL := new(game) fmt.Println(LOL) // \u0026amp;{ 0 []} fmt.Println(*LOL) // { 0 []} (*LOL).name = \u0026quot;LOL\u0026quot; // 實際上看起來是這樣，但是golang幫忙解決了 LOL.category = []string{\u0026quot;dota\u0026quot;} LOL.stars= 4 intel := cpu{name: \u0026quot;intel\u0026quot;, speed: 100} intel.getPrice() intel.getSpeed() } type cpu struct { name string speed float64 } func (cpu) getPrice() { fmt.Println(\u0026quot;get total price\u0026quot;) } // 像是往cpu這個類別加了一個方法 func (c cpu) getSpeed() { fmt.Println(c.speed) } // 第一個參數是receiver的概念，在Go中稱之為method  ","id":2,"section":"posts","summary":"struct struct類型 struct就很像是類的概念 package main import \u0026quot;fmt\u0026quot; func main() { type game struct { name string stars int category []string } fallguys := game{name: \u0026quot;fallguys\u0026quot;} // 第一種賦值方法 fallguys = game{ name: \u0026quot;糖豆人\u0026quo","tags":["Go"],"title":"struct","uri":"https://hungchang.co/2022/05/struct/","year":"2022"}],"tags":[{"title":"Go","uri":"https://hungchang.co/tags/go/"},{"title":"Node","uri":"https://hungchang.co/tags/node/"}]}